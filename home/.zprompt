# based on wunjo prompt theme
# and on Sebastian Celis's git prompt
autoload -Uz add-zsh-hook
setopt promptsubst

prompt_mic_help () {
  print "usage:
  prompt mic"
}

update_current_git_vars() {
    unset __CURRENT_GIT_BRANCH
    unset __CURRENT_GIT_BRANCH_STATUS
    unset __CURRENT_GIT_BRANCH_IS_DIRTY

    local st="$(LC_ALL=posix git status 2>/dev/null)"
    if [[ -n "$st" ]]; then
        local -a arr
        arr=(${(f)st})

        if [[ $arr[1] =~ 'Not currently on any branch.' ]]; then
            __CURRENT_GIT_BRANCH='no-branch'
        else
            __CURRENT_GIT_BRANCH="${arr[1][(w)4]}";
        fi

        if [[ $arr[2] =~ 'Your branch' ]]; then
            if [[ $arr[2] =~ 'ahead' ]]; then
                __CURRENT_GIT_BRANCH_STATUS='ahead'
            elif [[ $arr[2] =~ 'diverged' ]]; then
                __CURRENT_GIT_BRANCH_STATUS='diverged'
            elif [[ $arr[2] =~ 'up-to-date' ]]; then
                __CURRENT_GIT_BRANCH_STATUS='up-to-date'
            else
                __CURRENT_GIT_BRANCH_STATUS='behind'
            fi
        fi

        if [[ ! $st =~ 'nothing to commit' ]]; then
            __CURRENT_GIT_BRANCH_IS_DIRTY='1'
        fi
    fi
}

prompt_git_info() {
    if [ -n "$__CURRENT_GIT_BRANCH" ]; then
        local s="$__CURRENT_GIT_BRANCH"
        case "$__CURRENT_GIT_BRANCH_STATUS" in
            ahead)
            s+="↑"
            ;;
            diverged)
            s+="↕"
            ;;
            behind)
            s+="↓"
            ;;
            up-to-date)
            ;;
        esac
        if [ -n "$__CURRENT_GIT_BRANCH_IS_DIRTY" ]; then
            s+="%{$fg[red]%}⚡%{$reset_color%}"
        fi

        local open_p="%{$fg[blue]%}[%{$reset_color%}"
        local close_p="%{$fg[blue]%}]%{$reset_color%}"
        local branch="%{$fg[yellow]%}${s}%{$reset_color%}"
        echo "─$open_p${branch}$close_p"
    fi
}

prompt_ruby_info() {
  if [ -n "$RUBY_VERSION" ]; then
    local open_p="%{$fg[blue]%}[%{$reset_color%}"
    local close_p="%{$fg[blue]%}]%{$reset_color%}"
    echo "─${open_p}%{$fg[yellow]%}$RUBY_VERSION%{$reset_color%}${close_p}"
  fi
}

preexec_update_git_vars() {
  case "$1" in
    git*|tig)
      __EXECUTED_GIT_COMMAND=1
      ;;
  esac
}

precmd_update_git_vars() {
  if [ -n "$__EXECUTED_GIT_COMMAND" ]; then
    update_current_git_vars
    unset __EXECUTED_GIT_COMMAND
  fi
}
add-zsh-hook chpwd update_current_git_vars
add-zsh-hook preexec preexec_update_git_vars
add-zsh-hook precmd precmd_update_git_vars

# Notify, if an command is ready.
function _mic_notify { echo -ne '\a'}
# Does only make sense in X with URGENT notification
[[ $TERM != "linux" ]] && add-zsh-hook precmd _mic_notify

# <<< Snippet start (stolen from oh-my-zsh)
#usage: title short_tab_title looooooooooooooooooooooggggggg_windows_title
#http://www.faqs.org/docs/Linux-mini/Xterm-Title.html#ss3.1
#Fully support screen, iterm, and probably most modern xterm and rxvt
#Limited support for Apple Terminal (Terminal can't set window or tab separately)
function _mic_title {
  emulate -L zsh
  setopt prompt_subst

  [[ "$EMACS" == *term* ]] && return

  # if $2 is unset use $1 as default
  # if it is set and empty, leave it as is
  : ${2=$1}

  if [[ "$TERM" == screen* ]]; then
    print -Pn "\ek$1:q\e\\" #set screen hardstatus, usually truncated at 20 chars
  elif [[ "$TERM" == xterm* ]] || [[ "$TERM" == rxvt* ]] || [[ "$TERM" == ansi ]] || [[ "$TERM_PROGRAM" == "iTerm.app" ]]; then
    print -Pn "\e]2;$2:q\a" #set window name
    print -Pn "\e]1;$1:q\a" #set icon (=tab) name
  fi
}

ZSH_THEME_TERM_TAB_TITLE_IDLE="%15<..<%~%<<" #15 char left truncated PWD
ZSH_THEME_TERM_TITLE_IDLE="%n@%m: %~"

#Appears when you have the prompt
function _mic_termsupport_precmd {
  _mic_title $ZSH_THEME_TERM_TAB_TITLE_IDLE $ZSH_THEME_TERM_TITLE_IDLE
}

#Appears at the beginning of (and during) of command execution
function _mic_termsupport_preexec {
  emulate -L zsh
  setopt extended_glob

  # cmd name only, or if this is sudo or ssh, the next cmd
  local CMD=${1[(wr)^(*=*|sudo|ssh|mosh|rake|-*)]:gs/%/%%}
  local LINE="${2:gs/%/%%}"

  _mic_title '$CMD' '%100>...>$LINE%<<'
}

autoload -U add-zsh-hook
add-zsh-hook precmd _mic_termsupport_precmd
add-zsh-hook preexec _mic_termsupport_preexec

# >>> Snippet end

prompt_mic_setup() {
  local open_p="%{$fg[blue]%}[%{$reset_color%}"
  local close_p="%{$fg[blue]%}]%{$reset_color%}"

  local path_p="$open_p%{$fg[yellow]%}%~%{$reset_color%}$close_p"

  local user="%{$fg[cyan]%}%n%{$reset_color%}"
  local host="%{$fg[yellow]%}%m%{$reset_color%}"
  local user_host="${open_p}${user}@${host}${close_p}"

  local smile="%{$fg[green]%}:%)%{$reset_color%}"
  local cry="%{$fg[red]%}:(%{$reset_color%}"
  local smiley="${open_p}%(?,$smile,$cry)${close_p}"
  local return_code="%(?..%{$fg[red]%}%? ↵%{$reset_color%})"

  PS1="╭─${path_p}─${user_host}\$(prompt_git_info)\$(prompt_ruby_info)
╰─$smiley %# "

  PS2="${cur_cmd}> "
  RPS1="${return_code}"
  local user_host="${open_p}%_${close_p}> "

  export PS1 PS2 RPS1
}

prompt_mic_setup

# vim:set ft=zsh:
